const std = @import("std");
const thermite = @import("thermite");

// ============================================================================
// Shape-Based ASCII Renderer
// Based on: https://alexharri.com/blog/ascii-rendering
// ============================================================================

/// 6D shape vector - represents how much "ink" is in each region of a character
/// Regions are arranged:
///   [0] [1]
///   [2] [3]
///   [4] [5]
const ShapeVector = struct {
    v: [6]f32,

    fn zero() ShapeVector {
        return .{ .v = .{ 0, 0, 0, 0, 0, 0 } };
    }

    fn distance(self: ShapeVector, other: ShapeVector) f32 {
        var sum: f32 = 0;
        for (0..6) |i| {
            const d = self.v[i] - other.v[i];
            sum += d * d;
        }
        return @sqrt(sum);
    }

    fn magnitude(self: ShapeVector) f32 {
        var sum: f32 = 0;
        for (self.v) |val| {
            sum += val * val;
        }
        return @sqrt(sum);
    }

    fn applyContrast(self: *ShapeVector, exponent: f32) void {
        var max_val: f32 = 0.0001;
        for (self.v) |val| {
            if (val > max_val) max_val = val;
        }
        for (&self.v) |*val| {
            const normalized = val.* / max_val;
            val.* = std.math.pow(f32, normalized, exponent) * max_val;
        }
    }
};

/// A character and its measured shape vector
const CharShape = struct {
    char: []const u8,
    shape: ShapeVector,
};

/// Measured character set - shapes computed at runtime
const MeasuredCharset = struct {
    name: []const u8,
    chars: []const []const u8,
    shapes: []CharShape,
    allocator: std.mem.Allocator,

    fn init(allocator: std.mem.Allocator, name: []const u8, chars: []const []const u8) !MeasuredCharset {
        const shapes = try allocator.alloc(CharShape, chars.len);

        for (chars, 0..) |char, i| {
            shapes[i] = .{
                .char = char,
                .shape = measureCharShape(char),
            };
        }

        return .{
            .name = name,
            .chars = chars,
            .shapes = shapes,
            .allocator = allocator,
        };
    }

    fn deinit(self: *MeasuredCharset) void {
        self.allocator.free(self.shapes);
    }
};

// =============================================================================
// Measured Shape Vectors from Fira Code font (generated by rendering to canvas)
// Data from: x/website/src/components/AsciiScene/alphabets/six-samples.json
// Sampling points: (0.27,0.18), (0.73,0.18), (0.27,0.5), (0.73,0.5), (0.27,0.82), (0.73,0.82)
// =============================================================================
const MeasuredChar = struct { char: u8, v: [6]f32 };
const measured_ascii = [_]MeasuredChar{
    .{ .char = ' ', .v = .{ 0, 0, 0, 0, 0, 0 } },
    .{ .char = '!', .v = .{ 0.017, 0.010, 0.066, 0.047, 0.004, 0.001 } },
    .{ .char = '"', .v = .{ 0.126, 0.121, 0.004, 0.003, 0, 0 } },
    .{ .char = '#', .v = .{ 0.060, 0.077, 0.323, 0.295, 0.046, 0.020 } },
    .{ .char = '$', .v = .{ 0.147, 0.163, 0.176, 0.288, 0.089, 0.095 } },
    .{ .char = '%', .v = .{ 0.159, 0.086, 0.281, 0.264, 0.051, 0.089 } },
    .{ .char = '&', .v = .{ 0.120, 0.065, 0.315, 0.284, 0.071, 0.037 } },
    .{ .char = '\'', .v = .{ 0.037, 0.030, 0, 0, 0, 0 } },
    .{ .char = '*', .v = .{ 0, 0, 0.298, 0.283, 0, 0 } },
    .{ .char = '+', .v = .{ 0, 0, 0.182, 0.164, 0, 0 } },
    .{ .char = ',', .v = .{ 0, 0, 0, 0, 0.105, 0.025 } },
    .{ .char = '.', .v = .{ 0, 0, 0, 0, 0.009, 0.005 } },
    .{ .char = '/', .v = .{ 0, 0.156, 0.138, 0.054, 0.112, 0 } },
    .{ .char = '[', .v = .{ 0.175, 0.078, 0.200, 0, 0.130, 0.077 } },
    .{ .char = ']', .v = .{ 0.083, 0.168, 0, 0.193, 0.081, 0.122 } },
    .{ .char = '|', .v = .{ 0.049, 0.036, 0.063, 0.047, 0.025, 0.017 } },
    .{ .char = '(', .v = .{ 0.096, 0.078, 0.254, 0, 0.021, 0.064 } },
    .{ .char = ')', .v = .{ 0.083, 0.083, 0, 0.249, 0.069, 0.014 } },
    .{ .char = ':', .v = .{ 0, 0, 0.041, 0.033, 0.007, 0.003 } },
    .{ .char = ';', .v = .{ 0, 0, 0.041, 0.033, 0.106, 0.023 } },
    .{ .char = '<', .v = .{ 0, 0.013, 0.234, 0.033, 0, 0.017 } },
    .{ .char = '=', .v = .{ 0, 0, 0.208, 0.199, 0, 0 } },
    .{ .char = '>', .v = .{ 0.013, 0, 0.040, 0.230, 0.017, 0 } },
    .{ .char = '?', .v = .{ 0.116, 0.115, 0.078, 0.135, 0.015, 0 } },
    .{ .char = '@', .v = .{ 0.165, 0.132, 0.269, 0.374, 0.132, 0.176 } },
    .{ .char = '\\', .v = .{ 0.157, 0, 0.066, 0.122, 0, 0.111 } },
    .{ .char = '^', .v = .{ 0.184, 0.180, 0, 0, 0, 0 } },
    .{ .char = '`', .v = .{ 0.067, 0.051, 0, 0, 0, 0 } },
    .{ .char = '{', .v = .{ 0.056, 0.099, 0.159, 0.039, 0.027, 0.085 } },
    .{ .char = '}', .v = .{ 0.109, 0.045, 0.049, 0.149, 0.090, 0.019 } },
    .{ .char = '~', .v = .{ 0, 0, 0.176, 0.170, 0, 0 } },
    .{ .char = '-', .v = .{ 0, 0, 0.128, 0.124, 0, 0 } },
    .{ .char = '_', .v = .{ 0, 0, 0, 0, 0.156, 0.152 } },
    // Numbers
    .{ .char = '0', .v = .{ 0.113, 0.104, 0.377, 0.320, 0.040, 0.035 } },
    .{ .char = '1', .v = .{ 0.065, 0.030, 0.018, 0.123, 0.067, 0.085 } },
    .{ .char = '2', .v = .{ 0.135, 0.087, 0.068, 0.181, 0.100, 0.069 } },
    .{ .char = '3', .v = .{ 0.118, 0.093, 0.046, 0.282, 0.087, 0.026 } },
    .{ .char = '4', .v = .{ 0.020, 0.004, 0.275, 0.236, 0, 0.038 } },
    .{ .char = '5', .v = .{ 0.131, 0.087, 0.149, 0.243, 0.073, 0.032 } },
    .{ .char = '6', .v = .{ 0.089, 0.079, 0.334, 0.253, 0.040, 0.043 } },
    .{ .char = '7', .v = .{ 0.108, 0.144, 0.044, 0.145, 0.037, 0 } },
    .{ .char = '8', .v = .{ 0.117, 0.116, 0.324, 0.319, 0.061, 0.054 } },
    .{ .char = '9', .v = .{ 0.128, 0.104, 0.230, 0.330, 0.055, 0 } },
    // Uppercase
    .{ .char = 'A', .v = .{ 0.036, 0.030, 0.301, 0.305, 0.054, 0.058 } },
    .{ .char = 'B', .v = .{ 0.153, 0.107, 0.349, 0.329, 0.086, 0.039 } },
    .{ .char = 'C', .v = .{ 0.089, 0.137, 0.289, 0.001, 0.018, 0.104 } },
    .{ .char = 'D', .v = .{ 0.161, 0.094, 0.284, 0.305, 0.093, 0.016 } },
    .{ .char = 'E', .v = .{ 0.133, 0.111, 0.324, 0.096, 0.068, 0.091 } },
    .{ .char = 'F', .v = .{ 0.122, 0.127, 0.306, 0.111, 0.049, 0 } },
    .{ .char = 'G', .v = .{ 0.108, 0.124, 0.304, 0.269, 0.044, 0.086 } },
    .{ .char = 'H', .v = .{ 0.096, 0.096, 0.361, 0.354, 0.055, 0.055 } },
    .{ .char = 'I', .v = .{ 0.104, 0.100, 0.075, 0.061, 0.078, 0.074 } },
    .{ .char = 'J', .v = .{ 0.044, 0.144, 0, 0.273, 0.087, 0.024 } },
    .{ .char = 'K', .v = .{ 0.096, 0.101, 0.371, 0.134, 0.055, 0.069 } },
    .{ .char = 'L', .v = .{ 0.091, 0, 0.263, 0, 0.061, 0.099 } },
    .{ .char = 'M', .v = .{ 0.148, 0.147, 0.422, 0.414, 0.052, 0.053 } },
    .{ .char = 'N', .v = .{ 0.144, 0.090, 0.332, 0.357, 0.051, 0.078 } },
    .{ .char = 'O', .v = .{ 0.124, 0.120, 0.296, 0.294, 0.048, 0.042 } },
    .{ .char = 'P', .v = .{ 0.139, 0.132, 0.335, 0.241, 0.053, 0 } },
    .{ .char = 'Q', .v = .{ 0.124, 0.120, 0.294, 0.291, 0.049, 0.211 } },
    .{ .char = 'R', .v = .{ 0.150, 0.123, 0.350, 0.322, 0.056, 0.066 } },
    .{ .char = 'S', .v = .{ 0.136, 0.116, 0.180, 0.253, 0.088, 0.052 } },
    .{ .char = 'T', .v = .{ 0.149, 0.142, 0.077, 0.056, 0.002, 0.001 } },
    .{ .char = 'U', .v = .{ 0.096, 0.097, 0.283, 0.286, 0.051, 0.045 } },
    .{ .char = 'V', .v = .{ 0.102, 0.096, 0.239, 0.223, 0.003, 0.001 } },
    .{ .char = 'W', .v = .{ 0.096, 0.089, 0.418, 0.402, 0.075, 0.070 } },
    .{ .char = 'X', .v = .{ 0.102, 0.095, 0.226, 0.210, 0.059, 0.063 } },
    .{ .char = 'Y', .v = .{ 0.105, 0.099, 0.181, 0.163, 0.002, 0.001 } },
    .{ .char = 'Z', .v = .{ 0.107, 0.167, 0.168, 0.086, 0.102, 0.094 } },
    // Lowercase
    .{ .char = 'a', .v = .{ 0, 0, 0.225, 0.292, 0.082, 0.058 } },
    .{ .char = 'b', .v = .{ 0.133, 0, 0.295, 0.288, 0.068, 0.050 } },
    .{ .char = 'c', .v = .{ 0, 0, 0.269, 0.055, 0.028, 0.074 } },
    .{ .char = 'd', .v = .{ 0, 0.132, 0.286, 0.286, 0.061, 0.057 } },
    .{ .char = 'e', .v = .{ 0, 0, 0.335, 0.247, 0.038, 0.063 } },
    .{ .char = 'f', .v = .{ 0.039, 0.136, 0.222, 0.067, 0.013, 0 } },
    .{ .char = 'g', .v = .{ 0, 0.008, 0.285, 0.227, 0.192, 0.261 } },
    .{ .char = 'h', .v = .{ 0.132, 0, 0.296, 0.265, 0.054, 0.053 } },
    .{ .char = 'i', .v = .{ 0.047, 0.041, 0.061, 0.108, 0.066, 0.082 } },
    .{ .char = 'j', .v = .{ 0.001, 0.094, 0.026, 0.231, 0.124, 0.133 } },
    .{ .char = 'k', .v = .{ 0.133, 0, 0.352, 0.187, 0.053, 0.067 } },
    .{ .char = 'l', .v = .{ 0.165, 0.001, 0.150, 0.006, 0, 0.078 } },
    .{ .char = 'm', .v = .{ 0, 0, 0.346, 0.327, 0.051, 0.050 } },
    .{ .char = 'n', .v = .{ 0, 0, 0.294, 0.269, 0.054, 0.053 } },
    .{ .char = 'o', .v = .{ 0, 0, 0.275, 0.272, 0.047, 0.041 } },
    .{ .char = 'p', .v = .{ 0, 0, 0.293, 0.283, 0.219, 0.049 } },
    .{ .char = 'q', .v = .{ 0, 0, 0.280, 0.285, 0.062, 0.207 } },
    .{ .char = 'r', .v = .{ 0, 0, 0.253, 0.131, 0.073, 0.009 } },
    .{ .char = 's', .v = .{ 0, 0, 0.216, 0.208, 0.081, 0.045 } },
    .{ .char = 't', .v = .{ 0.033, 0, 0.235, 0.022, 0.000, 0.085 } },
    .{ .char = 'u', .v = .{ 0, 0, 0.271, 0.269, 0.067, 0.053 } },
    .{ .char = 'v', .v = .{ 0, 0, 0.244, 0.231, 0.004, 0.002 } },
    .{ .char = 'w', .v = .{ 0, 0, 0.380, 0.374, 0.071, 0.071 } },
    .{ .char = 'x', .v = .{ 0, 0, 0.247, 0.230, 0.059, 0.061 } },
    .{ .char = 'y', .v = .{ 0, 0, 0.247, 0.234, 0.143, 0.017 } },
    .{ .char = 'z', .v = .{ 0, 0, 0.114, 0.190, 0.082, 0.072 } },
};

/// Measure the shape of a character using real measured data when available
fn measureCharShape(char: []const u8) ShapeVector {
    // For space, return zero
    if (char.len == 1 and char[0] == ' ') {
        return ShapeVector.zero();
    }

    // Check measured ASCII data first (single-byte chars)
    if (char.len == 1) {
        const c = char[0];
        for (measured_ascii) |m| {
            if (m.char == c) {
                return .{ .v = m.v };
            }
        }
    }

    // Decode UTF-8 to get codepoint for Unicode chars
    const codepoint = std.unicode.utf8Decode(char) catch return ShapeVector.zero();

    // Unicode characters - use computed/estimated values
    return switch (codepoint) {
        // Box drawing - horizontal
        '─', '━' => .{ .v = .{ 0.0, 0.0, 0.3, 0.3, 0.0, 0.0 } },
        '╌', '╍' => .{ .v = .{ 0.0, 0.0, 0.2, 0.2, 0.0, 0.0 } },

        // Box drawing - vertical (thin line down center)
        '│', '┃' => .{ .v = .{ 0.05, 0.04, 0.06, 0.05, 0.02, 0.02 } }, // Based on | measurement
        '╎', '╏' => .{ .v = .{ 0.03, 0.03, 0.0, 0.0, 0.03, 0.03 } },

        // Corners - light
        '┌' => .{ .v = .{ 0.0, 0.0, 0.06, 0.15, 0.03, 0.0 } },
        '┐' => .{ .v = .{ 0.0, 0.0, 0.15, 0.06, 0.0, 0.03 } },
        '└' => .{ .v = .{ 0.03, 0.0, 0.06, 0.15, 0.0, 0.0 } },
        '┘' => .{ .v = .{ 0.0, 0.03, 0.15, 0.06, 0.0, 0.0 } },

        // Rounded corners
        '╭' => .{ .v = .{ 0.0, 0.0, 0.04, 0.12, 0.05, 0.0 } },
        '╮' => .{ .v = .{ 0.0, 0.0, 0.12, 0.04, 0.0, 0.05 } },
        '╰' => .{ .v = .{ 0.05, 0.0, 0.04, 0.12, 0.0, 0.0 } },
        '╯' => .{ .v = .{ 0.0, 0.05, 0.12, 0.04, 0.0, 0.0 } },

        // T-junctions
        '├' => .{ .v = .{ 0.03, 0.0, 0.06, 0.15, 0.03, 0.0 } },
        '┤' => .{ .v = .{ 0.0, 0.03, 0.15, 0.06, 0.0, 0.03 } },
        '┬' => .{ .v = .{ 0.0, 0.0, 0.15, 0.15, 0.03, 0.03 } },
        '┴' => .{ .v = .{ 0.03, 0.03, 0.15, 0.15, 0.0, 0.0 } },
        '┼' => .{ .v = .{ 0.03, 0.03, 0.15, 0.15, 0.03, 0.03 } },

        // Diagonals - based on / and \ measurements
        '╱' => .{ .v = .{ 0.0, 0.156, 0.138, 0.054, 0.112, 0.0 } }, // Same as /
        '╲' => .{ .v = .{ 0.157, 0.0, 0.066, 0.122, 0.0, 0.111 } }, // Same as \
        '╳' => .{ .v = .{ 0.08, 0.08, 0.10, 0.09, 0.06, 0.06 } },

        // Shade characters - uniform density
        '░' => .{ .v = .{ 0.25, 0.25, 0.25, 0.25, 0.25, 0.25 } },
        '▒' => .{ .v = .{ 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 } },
        '▓' => .{ .v = .{ 0.75, 0.75, 0.75, 0.75, 0.75, 0.75 } },
        '█' => .{ .v = .{ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } },

        // Half blocks
        '▀' => .{ .v = .{ 1.0, 1.0, 0.5, 0.5, 0.0, 0.0 } },
        '▄' => .{ .v = .{ 0.0, 0.0, 0.5, 0.5, 1.0, 1.0 } },
        '▌' => .{ .v = .{ 1.0, 0.0, 1.0, 0.0, 1.0, 0.0 } },
        '▐' => .{ .v = .{ 0.0, 1.0, 0.0, 1.0, 0.0, 1.0 } },

        // Quadrant blocks - 2x2 sub-pixel patterns
        // Our shape regions are 2x3, quadrants are 2x2, so we map:
        // top-left quadrant -> regions 0,2 (left column, top 2/3)
        // top-right quadrant -> regions 1,3 (right column, top 2/3)
        // bottom-left quadrant -> regions 2,4 (left column, bottom 2/3)
        // bottom-right quadrant -> regions 3,5 (right column, bottom 2/3)
        '▘' => .{ .v = .{ 1.0, 0.0, 0.5, 0.0, 0.0, 0.0 } },  // top-left
        '▝' => .{ .v = .{ 0.0, 1.0, 0.0, 0.5, 0.0, 0.0 } },  // top-right
        '▖' => .{ .v = .{ 0.0, 0.0, 0.5, 0.0, 1.0, 0.0 } },  // bottom-left
        '▗' => .{ .v = .{ 0.0, 0.0, 0.0, 0.5, 0.0, 1.0 } },  // bottom-right
        '▚' => .{ .v = .{ 1.0, 0.0, 0.5, 0.5, 0.0, 1.0 } },  // TL + BR diagonal
        '▞' => .{ .v = .{ 0.0, 1.0, 0.5, 0.5, 1.0, 0.0 } },  // TR + BL diagonal
        '▛' => .{ .v = .{ 1.0, 1.0, 1.0, 0.5, 1.0, 0.0 } },  // missing BR
        '▜' => .{ .v = .{ 1.0, 1.0, 0.5, 1.0, 0.0, 1.0 } },  // missing BL
        '▙' => .{ .v = .{ 1.0, 0.0, 1.0, 0.5, 1.0, 1.0 } },  // missing TR
        '▟' => .{ .v = .{ 0.0, 1.0, 0.5, 1.0, 1.0, 1.0 } },  // missing TL

        // Braille patterns (U+2800-U+28FF) - compute from dot pattern
        0x2800...0x28FF => |cp| blk: {
            const pattern = cp - 0x2800;
            // Braille dot layout:    1 4
            //                        2 5
            //                        3 6
            //                        7 8
            // Map to our 6 regions (2x3):
            const dot1: f32 = if (pattern & 0x01 != 0) 1.0 else 0.0; // top-left
            const dot2: f32 = if (pattern & 0x02 != 0) 1.0 else 0.0; // mid-left upper
            const dot3: f32 = if (pattern & 0x04 != 0) 1.0 else 0.0; // mid-left lower
            const dot4: f32 = if (pattern & 0x08 != 0) 1.0 else 0.0; // top-right
            const dot5: f32 = if (pattern & 0x10 != 0) 1.0 else 0.0; // mid-right upper
            const dot6: f32 = if (pattern & 0x20 != 0) 1.0 else 0.0; // mid-right lower
            const dot7: f32 = if (pattern & 0x40 != 0) 1.0 else 0.0; // bottom-left
            const dot8: f32 = if (pattern & 0x80 != 0) 1.0 else 0.0; // bottom-right

            break :blk ShapeVector{ .v = .{
                dot1,                       // region 0: top-left
                dot4,                       // region 1: top-right
                (dot2 + dot3) / 2.0,        // region 2: middle-left
                (dot5 + dot6) / 2.0,        // region 3: middle-right
                dot7,                       // region 4: bottom-left
                dot8,                       // region 5: bottom-right
            } };
        },

        else => ShapeVector.zero(),
    };
}

/// ASCII characters with dot-like patterns to mix with braille
const ascii_dot_chars = [_][]const u8{ " ", ".", ",", "'", "`", ":", ";", "!", "?", "\"", "-", "_", "i", "j" };

/// Full ASCII printable characters (for ASCII+Braille set)
const full_ascii_chars = [_][]const u8{
    " ", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?",
    "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O",
    "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_",
    "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
    "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~",
};

/// Generate braille + ASCII dot characters
fn generateBrailleChars(allocator: std.mem.Allocator) ![][]const u8 {
    const total = 256 + ascii_dot_chars.len;
    var chars = try allocator.alloc([]const u8, total);

    // First add braille characters
    for (0..256) |i| {
        const codepoint: u21 = @intCast(0x2800 + i);
        var buf = try allocator.alloc(u8, 3);
        const len = std.unicode.utf8Encode(codepoint, buf) catch 0;
        chars[i] = buf[0..len];
    }

    // Then add ASCII dot characters
    for (ascii_dot_chars, 0..) |c, i| {
        const buf = try allocator.alloc(u8, c.len);
        @memcpy(buf, c);
        chars[256 + i] = buf;
    }

    return chars;
}

/// Generate full ASCII + braille (all printable ASCII + all 256 braille)
fn generateAsciiBrailleChars(allocator: std.mem.Allocator) ![][]const u8 {
    const total = 256 + full_ascii_chars.len;
    var chars = try allocator.alloc([]const u8, total);

    // First add all braille characters
    for (0..256) |i| {
        const codepoint: u21 = @intCast(0x2800 + i);
        var buf = try allocator.alloc(u8, 3);
        const len = std.unicode.utf8Encode(codepoint, buf) catch 0;
        chars[i] = buf[0..len];
    }

    // Then add all printable ASCII
    for (full_ascii_chars, 0..) |c, i| {
        const buf = try allocator.alloc(u8, c.len);
        @memcpy(buf, c);
        chars[256 + i] = buf;
    }

    return chars;
}

// Character sets - just the characters, shapes measured at runtime
const ascii_chars = [_][]const u8{ " ", ".", "'", "`", "-", "_", "|", "/", "\\", "+", ":", "*" };
const unicode_box_chars = [_][]const u8{ " ", "─", "│", "┌", "┐", "└", "┘", "├", "┤", "┬", "┴", "┼", "╱", "╲", "╳", "╭", "╮", "╰", "╯" };
const unicode_block_chars = [_][]const u8{ " ", "░", "▒", "▓", "█", "▀", "▄", "▌", "▐", "▖", "▗", "▘", "▝", "▚", "▞" };

// Shade characters - simple uniform density gradient (5 levels)
const shade_chars = [_][]const u8{ " ", "░", "▒", "▓", "█" };

// Quadrant blocks in Bayer dither order (2x2 matrix: 0=TL, 1=BR, 2=TR, 3=BL)
// Gives 5 brightness levels with ordered dithering pattern
const quadrant_chars = [_][]const u8{
    " ",  // 0/4 - empty
    "▘",  // 1/4 - top-left only
    "▚",  // 2/4 - top-left + bottom-right (diagonal)
    "▜",  // 3/4 - missing bottom-left
    "█",  // 4/4 - full
};

// All 16 quadrant combinations for full 2x2 sub-pixel rendering
// Index is a 4-bit mask: bit 3=TL, bit 2=TR, bit 1=BL, bit 0=BR
const quadrant_all_chars = [_][]const u8{
    " ",  // 0000
    "▗",  // 0001 - bottom-right
    "▖",  // 0010 - bottom-left
    "▄",  // 0011 - bottom half
    "▝",  // 0100 - top-right
    "▐",  // 0101 - right half
    "▞",  // 0110 - top-right + bottom-left
    "▟",  // 0111 - missing top-left
    "▘",  // 1000 - top-left
    "▚",  // 1001 - top-left + bottom-right
    "▌",  // 1010 - left half
    "▙",  // 1011 - missing top-right
    "▀",  // 1100 - top half
    "▜",  // 1101 - missing bottom-left
    "▛",  // 1110 - missing bottom-right
    "█",  // 1111 - full
};

// 8x8 Bayer ordered dithering matrix (normalized to 0-1)
// Classic pattern that creates beautiful dispersed halftone effect
const bayer_8x8 = [8][8]f32{
    .{ 0.0 / 64.0, 32.0 / 64.0, 8.0 / 64.0, 40.0 / 64.0, 2.0 / 64.0, 34.0 / 64.0, 10.0 / 64.0, 42.0 / 64.0 },
    .{ 48.0 / 64.0, 16.0 / 64.0, 56.0 / 64.0, 24.0 / 64.0, 50.0 / 64.0, 18.0 / 64.0, 58.0 / 64.0, 26.0 / 64.0 },
    .{ 12.0 / 64.0, 44.0 / 64.0, 4.0 / 64.0, 36.0 / 64.0, 14.0 / 64.0, 46.0 / 64.0, 6.0 / 64.0, 38.0 / 64.0 },
    .{ 60.0 / 64.0, 28.0 / 64.0, 52.0 / 64.0, 20.0 / 64.0, 62.0 / 64.0, 30.0 / 64.0, 54.0 / 64.0, 22.0 / 64.0 },
    .{ 3.0 / 64.0, 35.0 / 64.0, 11.0 / 64.0, 43.0 / 64.0, 1.0 / 64.0, 33.0 / 64.0, 9.0 / 64.0, 41.0 / 64.0 },
    .{ 51.0 / 64.0, 19.0 / 64.0, 59.0 / 64.0, 27.0 / 64.0, 49.0 / 64.0, 17.0 / 64.0, 57.0 / 64.0, 25.0 / 64.0 },
    .{ 15.0 / 64.0, 47.0 / 64.0, 7.0 / 64.0, 39.0 / 64.0, 13.0 / 64.0, 45.0 / 64.0, 5.0 / 64.0, 37.0 / 64.0 },
    .{ 63.0 / 64.0, 31.0 / 64.0, 55.0 / 64.0, 23.0 / 64.0, 61.0 / 64.0, 29.0 / 64.0, 53.0 / 64.0, 21.0 / 64.0 },
};

// ============================================================================
// Render Buffer with Shape Sampling
// ============================================================================

const RenderBuffer = struct {
    // High-resolution buffer for line rasterization
    pixels: []f32,
    width: usize,
    height: usize,
    // Character cell dimensions
    cell_width: usize,
    cell_height: usize,
    // Output dimensions in characters
    char_width: usize,
    char_height: usize,

    allocator: std.mem.Allocator,

    const SUPERSAMPLE: usize = 4; // 4x4 supersampling per character cell

    fn init(allocator: std.mem.Allocator, char_width: usize, char_height: usize) !RenderBuffer {
        const cell_width = SUPERSAMPLE;
        const cell_height = SUPERSAMPLE * 2; // Characters are ~2:1 aspect ratio
        const pixel_width = char_width * cell_width;
        const pixel_height = char_height * cell_height;

        const pixels = try allocator.alloc(f32, pixel_width * pixel_height);
        @memset(pixels, 0);

        return .{
            .pixels = pixels,
            .width = pixel_width,
            .height = pixel_height,
            .cell_width = cell_width,
            .cell_height = cell_height,
            .char_width = char_width,
            .char_height = char_height,
            .allocator = allocator,
        };
    }

    fn deinit(self: *RenderBuffer) void {
        self.allocator.free(self.pixels);
    }

    fn clear(self: *RenderBuffer) void {
        @memset(self.pixels, 0);
    }

    fn setPixel(self: *RenderBuffer, x: isize, y: isize, value: f32) void {
        if (x < 0 or y < 0) return;
        const ux: usize = @intCast(x);
        const uy: usize = @intCast(y);
        if (ux >= self.width or uy >= self.height) return;
        const idx = uy * self.width + ux;
        self.pixels[idx] = @max(self.pixels[idx], value);
    }

    fn setPixelBlend(self: *RenderBuffer, x: isize, y: isize, value: f32, alpha: f32) void {
        if (x < 0 or y < 0) return;
        const ux: usize = @intCast(x);
        const uy: usize = @intCast(y);
        if (ux >= self.width or uy >= self.height) return;
        const idx = uy * self.width + ux;
        // Alpha blend: result = existing * (1 - alpha) + new * alpha
        self.pixels[idx] = self.pixels[idx] * (1.0 - alpha) + value * alpha;
    }

    fn getPixel(self: *const RenderBuffer, x: usize, y: usize) f32 {
        if (x >= self.width or y >= self.height) return 0;
        return self.pixels[y * self.width + x];
    }

    /// Draw an anti-aliased line using Xiaolin Wu's algorithm
    fn drawLine(self: *RenderBuffer, x0: f32, y0: f32, x1: f32, y1: f32) void {
        var xa = x0;
        var ya = y0;
        var xb = x1;
        var yb = y1;

        const steep = @abs(yb - ya) > @abs(xb - xa);

        if (steep) {
            std.mem.swap(f32, &xa, &ya);
            std.mem.swap(f32, &xb, &yb);
        }

        if (xa > xb) {
            std.mem.swap(f32, &xa, &xb);
            std.mem.swap(f32, &ya, &yb);
        }

        const dx = xb - xa;
        const dy = yb - ya;
        const gradient = if (dx < 0.0001) 1.0 else dy / dx;

        // First endpoint
        var xend = @round(xa);
        var yend = ya + gradient * (xend - xa);
        var xgap = 1.0 - (xa + 0.5 - @floor(xa + 0.5));
        const xpxl1: isize = @intFromFloat(xend);
        const ypxl1: isize = @intFromFloat(@floor(yend));

        if (steep) {
            self.setPixel(ypxl1, xpxl1, (1.0 - (yend - @floor(yend))) * xgap);
            self.setPixel(ypxl1 + 1, xpxl1, (yend - @floor(yend)) * xgap);
        } else {
            self.setPixel(xpxl1, ypxl1, (1.0 - (yend - @floor(yend))) * xgap);
            self.setPixel(xpxl1, ypxl1 + 1, (yend - @floor(yend)) * xgap);
        }

        var intery = yend + gradient;

        // Second endpoint
        xend = @round(xb);
        yend = yb + gradient * (xend - xb);
        xgap = xa + 0.5 - @floor(xa + 0.5);
        const xpxl2: isize = @intFromFloat(xend);
        const ypxl2: isize = @intFromFloat(@floor(yend));

        if (steep) {
            self.setPixel(ypxl2, xpxl2, (1.0 - (yend - @floor(yend))) * xgap);
            self.setPixel(ypxl2 + 1, xpxl2, (yend - @floor(yend)) * xgap);
        } else {
            self.setPixel(xpxl2, ypxl2, (1.0 - (yend - @floor(yend))) * xgap);
            self.setPixel(xpxl2, ypxl2 + 1, (yend - @floor(yend)) * xgap);
        }

        // Main loop
        var x = xpxl1 + 1;
        while (x < xpxl2) : (x += 1) {
            const iy: isize = @intFromFloat(@floor(intery));
            const frac = intery - @floor(intery);

            if (steep) {
                self.setPixel(iy, x, 1.0 - frac);
                self.setPixel(iy + 1, x, frac);
            } else {
                self.setPixel(x, iy, 1.0 - frac);
                self.setPixel(x, iy + 1, frac);
            }
            intery += gradient;
        }
    }

    /// Sample a cell and compute its 6D shape vector
    fn sampleCell(self: *const RenderBuffer, cx: usize, cy: usize) ShapeVector {
        var shape = ShapeVector.zero();

        const base_x = cx * self.cell_width;
        const base_y = cy * self.cell_height;

        // Sample 6 regions (2 columns x 3 rows)
        const region_w = self.cell_width / 2;
        const region_h = self.cell_height / 3;

        for (0..3) |row| {
            for (0..2) |col| {
                var sum: f32 = 0;
                var count: f32 = 0;

                const rx = base_x + col * region_w;
                const ry = base_y + row * region_h;

                for (0..region_h) |dy| {
                    for (0..region_w) |dx| {
                        sum += self.getPixel(rx + dx, ry + dy);
                        count += 1;
                    }
                }

                const idx = row * 2 + col;
                shape.v[idx] = if (count > 0) sum / count else 0;
            }
        }

        return shape;
    }

    /// Find the best matching character for a shape vector
    fn findBestChar(shape: ShapeVector, charset: []const CharShape) []const u8 {
        var best_char: []const u8 = " ";
        var best_dist: f32 = std.math.inf(f32);

        for (charset) |cs| {
            const dist = shape.distance(cs.shape);
            if (dist < best_dist) {
                best_dist = dist;
                best_char = cs.char;
            }
        }

        return best_char;
    }

    /// Get average intensity of a cell (for ordered dithering)
    fn sampleCellIntensity(self: *const RenderBuffer, cx: usize, cy: usize) f32 {
        const base_x = cx * self.cell_width;
        const base_y = cy * self.cell_height;

        var sum: f32 = 0;
        var count: f32 = 0;

        for (0..self.cell_height) |dy| {
            for (0..self.cell_width) |dx| {
                sum += self.getPixel(base_x + dx, base_y + dy);
                count += 1;
            }
        }

        return if (count > 0) sum / count else 0;
    }

    /// Sample intensity for a specific quadrant of a cell
    fn sampleQuadrantIntensity(self: *const RenderBuffer, cx: usize, cy: usize, qx: usize, qy: usize) f32 {
        const base_x = cx * self.cell_width + qx * (self.cell_width / 2);
        const base_y = cy * self.cell_height + qy * (self.cell_height / 2);
        const qw = self.cell_width / 2;
        const qh = self.cell_height / 2;

        var sum: f32 = 0;
        var count: f32 = 0;

        for (0..qh) |dy| {
            for (0..qw) |dx| {
                sum += self.getPixel(base_x + dx, base_y + dy);
                count += 1;
            }
        }

        return if (count > 0) sum / count else 0;
    }

    /// Get quadrant character using ordered (Bayer) dithering
    /// cx, cy are character cell coordinates
    /// contrast is applied to intensity before thresholding
    fn getOrderedDitherChar(self: *const RenderBuffer, cx: usize, cy: usize, contrast: f32) []const u8 {
        // Each character cell maps to 2x2 sub-pixels
        // Screen position for sub-pixels (for Bayer lookup)
        const sx = cx * 2;
        const sy = cy * 2;

        // Check each quadrant - sample its intensity and compare to Bayer threshold
        var mask: u4 = 0;

        // Top-left (bit 3)
        const tl_intensity = std.math.pow(f32, self.sampleQuadrantIntensity(cx, cy, 0, 0), 1.0 / contrast);
        const tl_threshold = bayer_8x8[sy % 8][sx % 8];
        if (tl_intensity > tl_threshold) mask |= 0b1000;

        // Top-right (bit 2)
        const tr_intensity = std.math.pow(f32, self.sampleQuadrantIntensity(cx, cy, 1, 0), 1.0 / contrast);
        const tr_threshold = bayer_8x8[sy % 8][(sx + 1) % 8];
        if (tr_intensity > tr_threshold) mask |= 0b0100;

        // Bottom-left (bit 1)
        const bl_intensity = std.math.pow(f32, self.sampleQuadrantIntensity(cx, cy, 0, 1), 1.0 / contrast);
        const bl_threshold = bayer_8x8[(sy + 1) % 8][sx % 8];
        if (bl_intensity > bl_threshold) mask |= 0b0010;

        // Bottom-right (bit 0)
        const br_intensity = std.math.pow(f32, self.sampleQuadrantIntensity(cx, cy, 1, 1), 1.0 / contrast);
        const br_threshold = bayer_8x8[(sy + 1) % 8][(sx + 1) % 8];
        if (br_intensity > br_threshold) mask |= 0b0001;

        return quadrant_all_chars[mask];
    }

    /// Draw a shaded sphere with shadow
    fn drawSphere(self: *RenderBuffer, light_angle: f32) void {
        const w: f32 = @floatFromInt(self.width);
        const h: f32 = @floatFromInt(self.height);
        const aspect = w / h;

        // Camera setup
        const cam_pos = Vec3{ .x = 0, .y = 0, .z = -4 };
        const sphere_center = Vec3{ .x = 0, .y = 0, .z = 0 };
        const sphere_radius: f32 = 1.2;
        const ground_y: f32 = 1.5; // Ground plane below sphere

        // Rotating light
        const light_raw = Vec3{
            .x = @cos(light_angle),
            .y = -0.5,
            .z = @sin(light_angle),
        };
        const light_dir = light_raw.normalize();

        // Render each pixel
        for (0..self.height) |py| {
            for (0..self.width) |px| {
                // Convert pixel to normalized device coordinates
                const u = (@as(f32, @floatFromInt(px)) / w - 0.5) * 2.0 * aspect;
                const v = (@as(f32, @floatFromInt(py)) / h - 0.5) * 2.0;

                // Ray direction (simple orthographic-ish projection)
                const ray_raw = Vec3{ .x = u * 0.5, .y = v * 0.5, .z = 1.0 };
                const ray_dir = ray_raw.normalize();

                var intensity: f32 = 0;

                // Check sphere intersection
                if (raySphereIntersect(cam_pos, ray_dir, sphere_center, sphere_radius)) |t| {
                    // Hit the sphere - compute shading
                    const hit_point = cam_pos.add(ray_dir.scale(t));
                    const normal = hit_point.sub(sphere_center).normalize();

                    // Diffuse lighting (Lambert)
                    const ndotl = @max(0.0, normal.dot(light_dir.scale(-1)));

                    // Specular highlight (Phong-ish)
                    const reflect = light_dir.sub(normal.scale(2.0 * light_dir.dot(normal)));
                    const view_dir = ray_dir.scale(-1);
                    const spec = std.math.pow(f32, @max(0.0, reflect.dot(view_dir)), 32.0);

                    // Rim lighting for that cool edge glow
                    const rim = std.math.pow(f32, 1.0 - @max(0.0, normal.dot(view_dir)), 2.0);

                    intensity = 0.1 + ndotl * 0.6 + spec * 0.4 + rim * 0.2;
                } else if (rayPlaneIntersect(cam_pos, ray_dir, ground_y)) |t| {
                    // Hit ground plane - check if in shadow
                    const hit_point = cam_pos.add(ray_dir.scale(t));

                    // Check shadow by casting ray toward light
                    const shadow_origin = hit_point.add(light_dir.scale(-0.01));
                    const in_shadow = raySphereIntersect(shadow_origin, light_dir.scale(-1), sphere_center, sphere_radius) != null;

                    // Distance from sphere center (for shadow falloff)
                    const dx = hit_point.x - sphere_center.x;
                    const dz = hit_point.z - sphere_center.z;
                    const dist_sq = dx * dx + dz * dz;

                    if (in_shadow) {
                        // Shadow with soft falloff
                        const shadow_strength = @max(0.0, 1.0 - dist_sq / 4.0);
                        intensity = 0.15 * (1.0 - shadow_strength * 0.7);
                    } else {
                        // Ground with gradient
                        intensity = 0.15 * @max(0.2, 1.0 - dist_sq / 8.0);
                    }
                }

                self.setPixel(@intCast(px), @intCast(py), intensity);
            }
        }
    }

    /// Draw a filled triangle with a given intensity using scanline rasterization
    fn drawFilledTriangle(self: *RenderBuffer, x0: f32, y0: f32, x1: f32, y1: f32, x2: f32, y2: f32, intensity: f32, alpha: f32) void {
        // Sort vertices by y coordinate
        var vx = [3]f32{ x0, x1, x2 };
        var vy = [3]f32{ y0, y1, y2 };

        // Simple bubble sort for 3 elements
        if (vy[0] > vy[1]) {
            std.mem.swap(f32, &vx[0], &vx[1]);
            std.mem.swap(f32, &vy[0], &vy[1]);
        }
        if (vy[1] > vy[2]) {
            std.mem.swap(f32, &vx[1], &vx[2]);
            std.mem.swap(f32, &vy[1], &vy[2]);
        }
        if (vy[0] > vy[1]) {
            std.mem.swap(f32, &vx[0], &vx[1]);
            std.mem.swap(f32, &vy[0], &vy[1]);
        }

        const top_y = @max(0, @as(isize, @intFromFloat(@floor(vy[0]))));
        const mid_y = @min(@as(isize, @intCast(self.height - 1)), @as(isize, @intFromFloat(@ceil(vy[1]))));
        const bot_y = @min(@as(isize, @intCast(self.height - 1)), @as(isize, @intFromFloat(@ceil(vy[2]))));

        // Helper to interpolate x at a given y along an edge
        const interpX = struct {
            fn f(ya: f32, xa: f32, yb: f32, xb: f32, y: f32) f32 {
                if (@abs(yb - ya) < 0.001) return xa;
                const t = (y - ya) / (yb - ya);
                return xa + t * (xb - xa);
            }
        }.f;

        // Top half of triangle (vy[0] to vy[1])
        var y: isize = top_y;
        while (y <= mid_y) : (y += 1) {
            const yf: f32 = @floatFromInt(y);
            if (yf < vy[0] or yf > vy[2]) continue;

            // Find x bounds at this y
            var x_left = interpX(vy[0], vx[0], vy[2], vx[2], yf); // Long edge
            var x_right: f32 = undefined;
            if (yf <= vy[1]) {
                x_right = interpX(vy[0], vx[0], vy[1], vx[1], yf); // Top-to-mid edge
            } else {
                x_right = interpX(vy[1], vx[1], vy[2], vx[2], yf); // Mid-to-bottom edge
            }

            if (x_left > x_right) std.mem.swap(f32, &x_left, &x_right);

            const start_x = @max(0, @as(isize, @intFromFloat(@floor(x_left))));
            const end_x = @min(@as(isize, @intCast(self.width - 1)), @as(isize, @intFromFloat(@ceil(x_right))));

            var x: isize = start_x;
            while (x <= end_x) : (x += 1) {
                self.setPixelBlend(x, y, intensity, alpha);
            }
        }

        // Bottom half of triangle (vy[1] to vy[2])
        y = mid_y + 1;
        while (y <= bot_y) : (y += 1) {
            const yf: f32 = @floatFromInt(y);
            if (yf < vy[0] or yf > vy[2]) continue;

            var x_left = interpX(vy[0], vx[0], vy[2], vx[2], yf); // Long edge
            var x_right = interpX(vy[1], vx[1], vy[2], vx[2], yf); // Mid-to-bottom edge

            if (x_left > x_right) std.mem.swap(f32, &x_left, &x_right);

            const start_x = @max(0, @as(isize, @intFromFloat(@floor(x_left))));
            const end_x = @min(@as(isize, @intCast(self.width - 1)), @as(isize, @intFromFloat(@ceil(x_right))));

            var x: isize = start_x;
            while (x <= end_x) : (x += 1) {
                self.setPixelBlend(x, y, intensity, alpha);
            }
        }
    }

    /// Draw a filled quad using scanline rasterization (avoids triangle seam artifacts)
    fn drawFilledQuad(self: *RenderBuffer, p0x: f32, p0y: f32, p1x: f32, p1y: f32, p2x: f32, p2y: f32, p3x: f32, p3y: f32, intensity: f32, alpha: f32) void {
        // Vertices in order: 0 -> 1 -> 2 -> 3 -> 0
        const vx = [4]f32{ p0x, p1x, p2x, p3x };
        const vy = [4]f32{ p0y, p1y, p2y, p3y };

        // Find y bounds
        var min_y: f32 = vy[0];
        var max_y: f32 = vy[0];
        for (vy[1..]) |y| {
            min_y = @min(min_y, y);
            max_y = @max(max_y, y);
        }

        const start_y = @max(0, @as(isize, @intFromFloat(@floor(min_y))));
        const end_y = @min(@as(isize, @intCast(self.height - 1)), @as(isize, @intFromFloat(@ceil(max_y))));

        // For each scanline, find intersections with all 4 edges
        var y: isize = start_y;
        while (y <= end_y) : (y += 1) {
            const yf: f32 = @floatFromInt(y);
            var x_intersections: [4]f32 = undefined;
            var num_intersections: usize = 0;

            // Check each edge (0-1, 1-2, 2-3, 3-0)
            for (0..4) |i| {
                const j = (i + 1) % 4;
                const y0 = vy[i];
                const y1 = vy[j];

                // Check if scanline crosses this edge
                if ((y0 <= yf and yf < y1) or (y1 <= yf and yf < y0)) {
                    const t = (yf - y0) / (y1 - y0);
                    const x = vx[i] + t * (vx[j] - vx[i]);
                    if (num_intersections < 4) {
                        x_intersections[num_intersections] = x;
                        num_intersections += 1;
                    }
                }
            }

            // Sort intersections and fill between pairs
            if (num_intersections >= 2) {
                // Simple sort for small array
                if (num_intersections == 2 and x_intersections[0] > x_intersections[1]) {
                    std.mem.swap(f32, &x_intersections[0], &x_intersections[1]);
                } else if (num_intersections > 2) {
                    // Bubble sort for more intersections
                    for (0..num_intersections) |_| {
                        for (0..num_intersections - 1) |k| {
                            if (x_intersections[k] > x_intersections[k + 1]) {
                                std.mem.swap(f32, &x_intersections[k], &x_intersections[k + 1]);
                            }
                        }
                    }
                }

                // Fill between first and last intersection (handles convex quads)
                const x_left = x_intersections[0];
                const x_right = x_intersections[num_intersections - 1];

                const start_x = @max(0, @as(isize, @intFromFloat(@floor(x_left))));
                const end_x = @min(@as(isize, @intCast(self.width - 1)), @as(isize, @intFromFloat(@ceil(x_right))));

                var x: isize = start_x;
                while (x <= end_x) : (x += 1) {
                    self.setPixelBlend(x, y, intensity, alpha);
                }
            }
        }
    }
};

// ============================================================================
// 3D Math
// ============================================================================

const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    fn add(self: Vec3, other: Vec3) Vec3 {
        return .{ .x = self.x + other.x, .y = self.y + other.y, .z = self.z + other.z };
    }

    fn sub(self: Vec3, other: Vec3) Vec3 {
        return .{ .x = self.x - other.x, .y = self.y - other.y, .z = self.z - other.z };
    }

    fn scale(self: Vec3, s: f32) Vec3 {
        return .{ .x = self.x * s, .y = self.y * s, .z = self.z * s };
    }

    fn dot(self: Vec3, other: Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }

    fn length(self: Vec3) f32 {
        return @sqrt(self.dot(self));
    }

    fn normalize(self: Vec3) Vec3 {
        const len = self.length();
        if (len < 0.0001) return .{ .x = 0, .y = 0, .z = 1 };
        return self.scale(1.0 / len);
    }

    fn cross(self: Vec3, other: Vec3) Vec3 {
        return .{
            .x = self.y * other.z - self.z * other.y,
            .y = self.z * other.x - self.x * other.z,
            .z = self.x * other.y - self.y * other.x,
        };
    }

    fn rotateX(self: Vec3, angle: f32) Vec3 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x, .y = self.y * c - self.z * s, .z = self.y * s + self.z * c };
    }

    fn rotateY(self: Vec3, angle: f32) Vec3 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x * c + self.z * s, .y = self.y, .z = -self.x * s + self.z * c };
    }

    fn rotateZ(self: Vec3, angle: f32) Vec3 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x * c - self.y * s, .y = self.x * s + self.y * c, .z = self.z };
    }
};

/// Ray-sphere intersection, returns distance to hit or null
fn raySphereIntersect(ray_origin: Vec3, ray_dir: Vec3, sphere_center: Vec3, sphere_radius: f32) ?f32 {
    const oc = ray_origin.sub(sphere_center);
    const a = ray_dir.dot(ray_dir);
    const b = 2.0 * oc.dot(ray_dir);
    const c = oc.dot(oc) - sphere_radius * sphere_radius;
    const discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0) return null;

    const t = (-b - @sqrt(discriminant)) / (2.0 * a);
    if (t > 0) return t;
    return null;
}

/// Ray-plane intersection (horizontal plane at y=plane_y)
fn rayPlaneIntersect(ray_origin: Vec3, ray_dir: Vec3, plane_y: f32) ?f32 {
    if (@abs(ray_dir.y) < 0.0001) return null;
    const t = (plane_y - ray_origin.y) / ray_dir.y;
    if (t > 0) return t;
    return null;
}

fn project(v: Vec3, buf: *const RenderBuffer, zoom: f32) struct { x: f32, y: f32 } {
    const distance: f32 = 5.0;
    const z = v.z + distance;
    const scale = zoom / z;

    const w: f32 = @floatFromInt(buf.width);
    const h: f32 = @floatFromInt(buf.height);

    return .{
        .x = v.x * scale * h / 2.0 + w / 2.0,
        .y = v.y * scale * h / 2.0 + h / 2.0,
    };
}

// ============================================================================
// Cube/Hypercube Geometry
// ============================================================================

const cube_vertices = [8]Vec3{
    .{ .x = -1, .y = -1, .z = -1 }, .{ .x = 1, .y = -1, .z = -1 },
    .{ .x = 1, .y = 1, .z = -1 },   .{ .x = -1, .y = 1, .z = -1 },
    .{ .x = -1, .y = -1, .z = 1 },  .{ .x = 1, .y = -1, .z = 1 },
    .{ .x = 1, .y = 1, .z = 1 },    .{ .x = -1, .y = 1, .z = 1 },
};

const cube_edges = [12][2]u8{
    .{ 0, 1 }, .{ 1, 2 }, .{ 2, 3 }, .{ 3, 0 }, // Front
    .{ 4, 5 }, .{ 5, 6 }, .{ 6, 7 }, .{ 7, 4 }, // Back
    .{ 0, 4 }, .{ 1, 5 }, .{ 2, 6 }, .{ 3, 7 }, // Connecting
};

// Cube faces (quads as pairs of triangles, CCW winding when viewed from outside)
// Each face is 4 vertex indices forming a quad
const cube_faces = [6][4]u8{
    .{ 0, 3, 2, 1 }, // Front  (z = -1)
    .{ 4, 5, 6, 7 }, // Back   (z = +1)
    .{ 0, 4, 7, 3 }, // Left   (x = -1)
    .{ 1, 2, 6, 5 }, // Right  (x = +1)
    .{ 3, 7, 6, 2 }, // Top    (y = +1)
    .{ 0, 1, 5, 4 }, // Bottom (y = -1)
};

// 4D Hypercube (Tesseract)
const Vec4 = struct {
    x: f32,
    y: f32,
    z: f32,
    w: f32,

    fn rotateXY(self: Vec4, angle: f32) Vec4 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x * c - self.y * s, .y = self.x * s + self.y * c, .z = self.z, .w = self.w };
    }

    fn rotateXZ(self: Vec4, angle: f32) Vec4 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x * c - self.z * s, .y = self.y, .z = self.x * s + self.z * c, .w = self.w };
    }

    fn rotateXW(self: Vec4, angle: f32) Vec4 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x * c - self.w * s, .y = self.y, .z = self.z, .w = self.x * s + self.w * c };
    }

    fn rotateYZ(self: Vec4, angle: f32) Vec4 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x, .y = self.y * c - self.z * s, .z = self.y * s + self.z * c, .w = self.w };
    }

    fn rotateYW(self: Vec4, angle: f32) Vec4 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x, .y = self.y * c - self.w * s, .z = self.z, .w = self.y * s + self.w * c };
    }

    fn rotateZW(self: Vec4, angle: f32) Vec4 {
        const c = @cos(angle);
        const s = @sin(angle);
        return .{ .x = self.x, .y = self.y, .z = self.z * c - self.w * s, .w = self.z * s + self.w * c };
    }

    fn projectTo3D(self: Vec4, distance: f32) Vec3 {
        const w = self.w + distance;
        const s = distance / w;
        return .{ .x = self.x * s, .y = self.y * s, .z = self.z * s };
    }

    fn add(self: Vec4, other: Vec4) Vec4 {
        return .{ .x = self.x + other.x, .y = self.y + other.y, .z = self.z + other.z, .w = self.w + other.w };
    }

    fn sub(self: Vec4, other: Vec4) Vec4 {
        return .{ .x = self.x - other.x, .y = self.y - other.y, .z = self.z - other.z, .w = self.w - other.w };
    }

    fn scale(self: Vec4, s: f32) Vec4 {
        return .{ .x = self.x * s, .y = self.y * s, .z = self.z * s, .w = self.w * s };
    }

    fn dot(self: Vec4, other: Vec4) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w;
    }

    fn length(self: Vec4) f32 {
        return @sqrt(self.dot(self));
    }

    fn normalize(self: Vec4) Vec4 {
        const len = self.length();
        if (len < 0.0001) return .{ .x = 0, .y = 0, .z = 0, .w = 1 };
        return self.scale(1.0 / len);
    }
};

// Generate hypercube vertices
fn generateHypercubeVertices() [16]Vec4 {
    var verts: [16]Vec4 = undefined;
    for (0..16) |i| {
        verts[i] = .{
            .x = if (i & 1 != 0) 1.0 else -1.0,
            .y = if (i & 2 != 0) 1.0 else -1.0,
            .z = if (i & 4 != 0) 1.0 else -1.0,
            .w = if (i & 8 != 0) 1.0 else -1.0,
        };
    }
    return verts;
}

// Generate hypercube edges (vertices differing in exactly one coordinate)
fn generateHypercubeEdges() [32][2]u8 {
    var edges: [32][2]u8 = undefined;
    var idx: usize = 0;
    for (0..16) |i| {
        for (0..4) |bit| {
            const j = i ^ (@as(usize, 1) << @intCast(bit));
            if (j > i) {
                edges[idx] = .{ @intCast(i), @intCast(j) };
                idx += 1;
            }
        }
    }
    return edges;
}

const hypercube_vertices = generateHypercubeVertices();
const hypercube_edges = generateHypercubeEdges();

// Generate hypercube faces (24 square faces - vertices differing in exactly 2 coordinates)
fn generateHypercubeFaces() [24][4]u8 {
    var faces: [24][4]u8 = undefined;
    var idx: usize = 0;

    // For each pair of dimensions (6 pairs for 4D)
    const dims = [_][2]u3{ .{ 0, 1 }, .{ 0, 2 }, .{ 0, 3 }, .{ 1, 2 }, .{ 1, 3 }, .{ 2, 3 } };
    for (dims) |dim_pair| {
        const d0 = dim_pair[0];
        const d1 = dim_pair[1];
        const bit0: u4 = @as(u4, 1) << d0;
        const bit1: u4 = @as(u4, 1) << d1;

        // For each combination of the other 2 dimensions (4 faces per pair)
        for (0..16) |base| {
            // Skip if this base has bits set in our varying dimensions
            if (base & bit0 != 0 or base & bit1 != 0) continue;

            // Create quad: base, base+bit0, base+bit0+bit1, base+bit1
            faces[idx] = .{
                @intCast(base),
                @intCast(base | bit0),
                @intCast(base | bit0 | bit1),
                @intCast(base | bit1),
            };
            idx += 1;
        }
    }
    return faces;
}

const hypercube_faces = generateHypercubeFaces();

// ============================================================================
// Main
// ============================================================================

const RenderMode = enum { cube, hypercube, sphere };

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Terminal setup
    const term_info = try thermite.terminal.getTerminalInfo();
    const fd = term_info.fd;
    const width: usize = term_info.width;
    const height: usize = term_info.height - 2; // Leave room for status

    try thermite.terminal.enterRawMode(fd);
    defer thermite.terminal.exitRawMode(fd) catch {};
    try thermite.terminal.hideCursor(fd);
    defer thermite.terminal.showCursor(fd) catch {};

    // Create render buffer
    var buffer = try RenderBuffer.init(allocator, width, height);
    defer buffer.deinit();

    // Output buffer
    var output: std.ArrayList(u8) = .{};
    defer output.deinit(allocator);

    // Build measured character sets at startup
    var ascii_set = try MeasuredCharset.init(allocator, "ASCII", &ascii_chars);
    defer ascii_set.deinit();
    var box_set = try MeasuredCharset.init(allocator, "Unicode Box", &unicode_box_chars);
    defer box_set.deinit();
    var block_set = try MeasuredCharset.init(allocator, "Block", &unicode_block_chars);
    defer block_set.deinit();

    var shade_set = try MeasuredCharset.init(allocator, "Shade", &shade_chars);
    defer shade_set.deinit();

    var quadrant_set = try MeasuredCharset.init(allocator, "Quadrant", &quadrant_all_chars);
    defer quadrant_set.deinit();

    // Generate braille charset (256 braille + dot-like ASCII)
    const braille_char_data = try generateBrailleChars(allocator);
    defer {
        for (braille_char_data) |c| allocator.free(c);
        allocator.free(braille_char_data);
    }
    var braille_set = try MeasuredCharset.init(allocator, "Braille", braille_char_data);
    defer braille_set.deinit();

    // Generate ASCII+Braille charset (all printable ASCII + all braille)
    const ascii_braille_data = try generateAsciiBrailleChars(allocator);
    defer {
        for (ascii_braille_data) |c| allocator.free(c);
        allocator.free(ascii_braille_data);
    }
    var ascii_braille_set = try MeasuredCharset.init(allocator, "ASCII+Braille", ascii_braille_data);
    defer ascii_braille_set.deinit();

    // Character set selection (cycle with 'c')
    const charsets = [_]*MeasuredCharset{ &ascii_set, &shade_set, &quadrant_set, &braille_set, &ascii_braille_set, &box_set, &block_set };
    var charset_idx: usize = 0;

    // Render mode (cycle with 'm')
    var mode: RenderMode = .cube;

    // Contrast (adjust with +/-)
    var contrast: f32 = 2.5;

    // Zoom (adjust with a/z)
    var zoom: f32 = 2.0;

    // Pause
    var paused = false;

    // Solid faces toggle
    var solid = false;

    // Face opacity (0.0 = transparent, 1.0 = opaque)
    var opacity: f32 = 1.0;

    // Ordered dithering toggle (uses Bayer matrix with quadrant blocks)
    var dithering = false;

    // Grayscale mode (adds gray shading to dithering)
    var grayscale = false;

    // Number of gray levels (2 = black/white, more = smoother gradients)
    var gray_levels: u8 = 20;

    var angle: f32 = 0;
    var angle4d: f32 = 0;

    while (true) {
        // Input handling
        if (thermite.terminal.readKey(fd)) |key| {
            switch (key) {
                'q', 3 => break, // q or Ctrl+C
                'c' => charset_idx = (charset_idx + 1) % charsets.len,
                'm' => mode = switch (mode) {
                    .cube => .hypercube,
                    .hypercube => .sphere,
                    .sphere => .cube,
                },
                '+', '=' => contrast = @min(5.0, contrast + 0.25),
                '-', '_' => contrast = @max(0.5, contrast - 0.25),
                'a' => zoom = @min(10.0, zoom * 1.2),
                'z' => zoom = @max(0.5, zoom / 1.2),
                's' => solid = !solid,
                'd' => dithering = !dithering,
                'g' => grayscale = !grayscale,
                ',' => gray_levels = @max(2, gray_levels -| 2),
                '.' => gray_levels = @min(64, gray_levels + 2),
                '[' => opacity = @max(0.1, opacity - 0.1),
                ']' => opacity = @min(1.0, opacity + 0.1),
                ' ' => paused = !paused,
                else => {},
            }
        }

        // Clear buffer
        buffer.clear();

        // Draw geometry based on mode
        switch (mode) {
            .sphere => {
                buffer.drawSphere(angle);
            },
            .hypercube => {
                // Transform all 4D vertices and project to 3D
                var transformed_4d: [16]Vec4 = undefined;
                var transformed_3d: [16]Vec3 = undefined;
                for (hypercube_vertices, 0..) |v, i| {
                    transformed_4d[i] = v.rotateXZ(angle).rotateZW(angle * 0.5);
                    transformed_3d[i] = transformed_4d[i].projectTo3D(3.0);
                }

                if (solid) {
                    // Fixed 4D light direction - hypercube rotates relative to this
                    const light_4d = (Vec4{ .x = -0.5, .y = -0.8, .z = 0.4, .w = 0.3 }).normalize();

                    // Draw solid faces with back-face culling
                    for (hypercube_faces) |face| {
                        // Get 4D vertices for this face (after rotation)
                        const v0_4d = transformed_4d[face[0]];
                        const v1_4d = transformed_4d[face[1]];
                        const v2_4d = transformed_4d[face[2]];
                        const v3_4d = transformed_4d[face[3]];

                        // Compute face centroid in 4D - direction from origin = outward normal
                        const centroid_4d = v0_4d.add(v1_4d).add(v2_4d).add(v3_4d).scale(0.25);
                        const normal_4d = centroid_4d.normalize();

                        // 4D lighting: dot product of face normal with light direction
                        const ndotl_4d = @max(0.0, normal_4d.dot(light_4d.scale(-1)));

                        // Get 3D projected vertices for drawing
                        const v0 = transformed_3d[face[0]];
                        const v1 = transformed_3d[face[1]];
                        const v2 = transformed_3d[face[2]];
                        const v3 = transformed_3d[face[3]];

                        // 3D normal for back-face culling only
                        const edge1 = v1.sub(v0);
                        const edge2 = v3.sub(v0);
                        const normal_3d = edge1.cross(edge2).normalize();

                        // Back-face culling in projected 3D space
                        if (normal_3d.z > 0) continue;

                        const intensity = 0.1 + ndotl_4d * 0.9;

                        // Project and draw
                        const p0 = project(v0, &buffer, zoom);
                        const p1 = project(v1, &buffer, zoom);
                        const p2 = project(v2, &buffer, zoom);
                        const p3 = project(v3, &buffer, zoom);

                        buffer.drawFilledQuad(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, intensity, opacity);
                    }
                } else {
                    // Wireframe mode
                    for (hypercube_edges) |edge| {
                        const v0 = transformed_3d[edge[0]];
                        const v1 = transformed_3d[edge[1]];

                        const p0 = project(v0, &buffer, zoom);
                        const p1 = project(v1, &buffer, zoom);

                        buffer.drawLine(p0.x, p0.y, p1.x, p1.y);
                    }
                }
            },
            .cube => {
                // Transform all vertices first
                var transformed: [8]Vec3 = undefined;
                for (cube_vertices, 0..) |v, i| {
                    transformed[i] = v.rotateY(angle).rotateX(angle * 0.7).rotateZ(angle * 0.3);
                }

                if (solid) {
                    // Light direction (fixed, pointing into screen and down-left)
                    const light_dir = (Vec3{ .x = -0.5, .y = -0.7, .z = 0.5 }).normalize();

                    // Draw solid faces with back-face culling and lighting
                    for (cube_faces) |face| {
                        const v0 = transformed[face[0]];
                        const v1 = transformed[face[1]];
                        const v2 = transformed[face[2]];
                        const v3 = transformed[face[3]];

                        // Calculate face normal (cross product of two edges)
                        const edge1 = v1.sub(v0);
                        const edge2 = v3.sub(v0);
                        const normal = edge1.cross(edge2).normalize();

                        // Back-face culling: skip if normal points away from camera (positive z)
                        if (normal.z > 0) continue;

                        // Calculate lighting intensity (Lambert diffuse)
                        const ndotl = @max(0.0, normal.dot(light_dir.scale(-1)));
                        const intensity = 0.15 + ndotl * 0.85; // Ambient + diffuse

                        // Project and draw
                        const p0 = project(v0, &buffer, zoom);
                        const p1 = project(v1, &buffer, zoom);
                        const p2 = project(v2, &buffer, zoom);
                        const p3 = project(v3, &buffer, zoom);

                        buffer.drawFilledQuad(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, intensity, opacity);
                    }
                } else {
                    // Wireframe mode
                    for (cube_edges) |edge| {
                        const v0 = transformed[edge[0]];
                        const v1 = transformed[edge[1]];

                        const p0 = project(v0, &buffer, zoom);
                        const p1 = project(v1, &buffer, zoom);

                        buffer.drawLine(p0.x, p0.y, p1.x, p1.y);
                    }
                }
            },
        }

        // Render to characters
        output.clearRetainingCapacity();
        try output.appendSlice(allocator, "\x1b[H"); // Home

        const charset = charsets[charset_idx];

        for (0..buffer.char_height) |cy| {
            for (0..buffer.char_width) |cx| {
                if (dithering and grayscale) {
                    // Grayscale dithering: use gray color + quadrant blocks
                    const intensity = buffer.sampleCellIntensity(cx, cy);
                    const adjusted = std.math.pow(f32, @min(1.0, intensity), 1.0 / contrast);

                    // Map intensity directly to gray value (0-130 range, avoid harsh white)
                    const max_bright: f32 = 130.0;
                    const gray_f = adjusted * max_bright;
                    const gray_value: u8 = @intFromFloat(@min(max_bright, gray_f));

                    // Dither with a small fixed step (capped at 12 to avoid harsh contrast)
                    // This keeps the two dithered colors always close together
                    const raw_step = @as(u8, @intFromFloat(max_bright)) / gray_levels;
                    const dither_step: u8 = @min(12, @max(1, raw_step));
                    const next_gray: u8 = @min(@as(u8, @intFromFloat(max_bright)), gray_value +| dither_step);

                    // Use fractional part of scaled intensity for dithering
                    const scaled = adjusted * @as(f32, @floatFromInt(gray_levels));
                    const remainder = scaled - @floor(scaled);

                    // Dither the remainder using Bayer
                    const sx = cx * 2;
                    const sy = cy * 2;
                    var mask: u4 = 0;

                    const tl_threshold = bayer_8x8[sy % 8][sx % 8];
                    if (remainder > tl_threshold) mask |= 0b1000;
                    const tr_threshold = bayer_8x8[sy % 8][(sx + 1) % 8];
                    if (remainder > tr_threshold) mask |= 0b0100;
                    const bl_threshold = bayer_8x8[(sy + 1) % 8][sx % 8];
                    if (remainder > bl_threshold) mask |= 0b0010;
                    const br_threshold = bayer_8x8[(sy + 1) % 8][(sx + 1) % 8];
                    if (remainder > br_threshold) mask |= 0b0001;

                    // Always set both fg and bg to avoid color bleeding
                    // Use upper half block (▀) with fg=top color, bg=bottom color for 2-color per cell
                    // But for simplicity, use quadrant blocks with fg=bright, bg=dark
                    var color_buf: [32]u8 = undefined;
                    const color_str = std.fmt.bufPrint(&color_buf, "\x1b[38;2;{d};{d};{d};48;2;{d};{d};{d}m", .{
                        next_gray, next_gray, next_gray,
                        gray_value, gray_value, gray_value,
                    }) catch "\x1b[0m";
                    try output.appendSlice(allocator, color_str);
                    try output.appendSlice(allocator, quadrant_all_chars[mask]);
                } else if (dithering) {
                    // Ordered Bayer dithering with quadrant blocks (no color)
                    const char = buffer.getOrderedDitherChar(cx, cy, contrast);
                    try output.appendSlice(allocator, char);
                } else {
                    // Shape-based character matching
                    var shape = buffer.sampleCell(cx, cy);
                    shape.applyContrast(contrast);
                    const char = RenderBuffer.findBestChar(shape, charset.shapes);
                    try output.appendSlice(allocator, char);
                }
            }
            // Reset colors at end of line if using grayscale
            if (grayscale and dithering) {
                try output.appendSlice(allocator, "\x1b[0m");
            }
            try output.appendSlice(allocator, "\r\n");
        }

        // Status line
        const mode_str = switch (mode) {
            .cube => "Cube",
            .hypercube => "Hypercube",
            .sphere => "Sphere",
        };
        const solid_str = if (solid) "ON" else "OFF";
        const dither_str = if (dithering) "ON" else "OFF";
        const gray_str = if (grayscale) "ON" else "OFF";
        const status = try std.fmt.allocPrint(allocator, "\x1b[0m\x1b[K[m]:{s} [s]:{s} [d]:{s} [g]:{s} [,.]:{d} [+/-]:{d:.1}", .{ mode_str, solid_str, dither_str, gray_str, gray_levels, contrast });
        defer allocator.free(status);
        try output.appendSlice(allocator, status);

        _ = try std.posix.write(fd, output.items);

        // Update rotation
        if (!paused) {
            angle += 0.02;
            angle4d += 0.015;
        }

        std.Thread.sleep(25 * std.time.ns_per_ms);
    }

    try thermite.terminal.clearScreen(fd);
}
